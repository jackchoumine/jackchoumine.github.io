# 数组

数组是多个变量的**有序存储结构**。

## 特点

> 长度动态：数组长度可动态调整，可动态添加或减少元素。
> 元素类型动态：元素不要求类型一致。
> 索引是自然数：从0开始。

可通过 `Object.preventExtensions()`、`Object.seal()`、`Object.freeze()` 禁止扩展数组。

## 数组构造和类型判断

### 构造

| 方式           | 例子                              | 使用频率            | 注意点                         |
| -------------- | --------------------------------- | ------------------- | ------------------------------ |
| 字面量         | `const arr = [1,2]`               | ⭐️ ⭐️ ⭐️ ⭐️ ⭐️ |                                |
| Array.of       | `const arr = Array.of(1,2)`       | ⭐️ ⭐️ ⭐️         | 参数列表是数组元素             |
| Array.from     | `const strArr = Array.from('hi')` | ⭐️ ⭐️             | 从可迭代对象或者类数组创建数组 |
| Array 构造函数 | `const arr = new Array(1,2)`      | ⭐️                 | 参数不同，表现不同             |

> 构造函数参数不同，行为不同，很少直接使用。

```js
const numArr = new Array(4) // 创建一个长度为4的空数组
const numArr2 = new Array(4，3) // [4,3] 两个参数，表示元素
const numArr3 = new Array(4.2) // 一个非整数参数，报错 RangeError: Invalid array length
```

> Array.from 还可接受第二个第三个参数：第二个参数是迭代函数，第三个是 this 对象，和先创建数组再调用 map 效果一样。

```ts
const arr = Array.from({ length: 4 }, (ele, index) => {
  return index * 2
})
// 结果和上面的一样
const arr2 = Array.from({ length: 4 }).map((ele, index) => {
  return index * 2
})
const set = new Set([1, 2, 3])
const arr3 = Array.from(set, ele => {
  return ele * 2
})

/**
 * 串行生成器
 * @param {number} first 第一个元素
 * @param {number} last 最后一个元素
 * @param {number} step 步长
 * @returns number[]
 */
function range(first: number, last: number, step: number) {
  return Array.from({ length: (last - first) / step + 1 }, (_, i) => first + i * step)
}

const arr5 = range(2, 100, 2)
console.log(arr5)

const images = document.querySelectorAll('img')
const sources = Array.from(images, image => image.src)
```

### 数组判断

使用`Array.isArray`和 type:

```js
function type(value) {
  return Object.prototype.toString.call(value).slice(8, -1).toLowerCase()
}
```

## 操作方法

### 添加元素

| 方法    | 参数                                          | 返回值         | 例子                          | 注意点                         |
| ------- | --------------------------------------------- | -------------- | ----------------------------- | ------------------------------ |
| push    | 需要添加的元素                                | 数组长度       | `const len = [].push(1,2)`    | 从尾部追加元素，返回的数组长度 |
| unshift | 需要添加的元素                                | 数组长度       | `const len = [].unshift(1,2)` | 从头部追加元素，返回的数组长度 |
| splice  | (start,removeCount,replaceItem1,replaceItem2) | 移除的元素数组 |                               | 还可以用来移除元素             |

```js
const numberArr = [1, 2, 3, 4]
numberArr.splice(1, 0, '1', '2') // 从索引 1 开始添加元素，原来的 2 被往后推
console.log(numberArr) // [1, '1', '2', 2, 3, 4]
```

> fill 可以用来填充数组，返回填充后的数组。

```js
const numberArr = [1, 2, 3, 4]
const newArr = numberArr.fill('1', 1, 2) // [1,'1',3,4]
```

### 移除元素

| 方法   | 参数                | 返回值               | 注意点     |
| ------ | ------------------- | -------------------- | ---------- |
| pop    |                     | 移除的元素           | 从尾部移除 |
| shift  |                     | 移除的元素           | 从头部移除 |
| splice | (start,removeCount) | 被移除元素组成的数组 |            |

### 是否包含

`includes` 用于查询是否包含某个元素。

### 查询元素

| 方法          | 参数           | 返回值                 | 注意点                             |
| ------------- | -------------- | ---------------------- | ---------------------------------- |
| find          | findMethod     | 找到的第一个元素       | 找不到，返回 undefined             |
| findIndex     | findMethod     | 找到的第一个元素的索引 | 找不到，返回 -1                    |
| findLast      | findMethod     | 找到的第一个元素       | 从后往前找，找不到，返回 undefined |
| findLastIndex | findMethod     | 找到的第一个元素的索引 | 从后往前找，找不到，返回 -1        |
| indexOf       | 需要查询的元素 | 找到的第一个元素的索引 | 找不到，返回 -1                    |

```js
const than10 = [1, 8, 7, 12, 17].find(ele => ele > 10)
```

### 合并数组

`concat` 用于合并多个数组，返回合并后的数组。

```js
const array1 = ['a', 'b', 'c']
const array2 = ['d', 'e', 'f']
const array3 = ['g', 'h']
const array4 = array1.concat(array2, array3)
console.log(array4)
```

### 切片

`slice` 可将数组切片，返回切片的数组，不会改变原数组，不包含结束下标的元素。

```js
const counts = [1, 2, 3, 4, 5]
const sliceArr = counts.slice(0, 3)
console.log({ sliceArr }) // [1,2,3]
```

### 遍历

> reduce -- 遍历元素，每次都把上次操作结果和当前元素传入遍历函数，返回一个聚合的结果。

```js
// 计算元素的和
const counts = [1, 2, 3, 4, 5]
const sum = counts.reduce((total, cur, index, arr) => {
  console.log({ cur, total, index, arr })
  return total + cur
}, 0)
console.log({ sum })

// 拼接字符串数组
const strArr = ['J', 'a', 'v', 'a', 'S', 'c', 'r', 'i', 'p', 't']
const string = strArr.reduce((acc, cur) => {
  return acc + cur
}, '')
console.log({ string })

// 合并对象数组
const objArr = [{ city: 'GuiYang' }, { name: 'Jack' }, { age: 20 }]
const mergedObj = objArr.reduce((acc, cur) => {
  return {
    ...acc,
    ...cur,
  }
}, {})
console.log({ mergedObj })
```

> reduceRight -- 对累加器（accumulator）和数组的每个值（按从右到左的顺序）应用一个函数，返回一个聚合的结果。和 reduce 操作类似。

```js
const strArr = ['J', 'a', 'v', 'a', 'S', 'c', 'r', 'i', 'p', 't']
const string = strArr.reduceRight((acc, cur) => {
  return acc + cur
}, '')
console.log({ string }) // tpircSavaJ
```

> forEach -- 遍历元素，没返回值。

```js
const objArr = [{ city: 'GuiYang' }, { name: 'Jack' }, { age: 30 }]
objArr.forEach(item => {
  console.log({ item })
})
```

> filter -- 挑选符合条件的元素，返回挑选的元素组成的数组。

```js
const counts = [1, 2, 3, 4, 5]
const moreThan3 = counts.filter(ele => ele > 3)
console.log({ moreThan3 }) // [4,5]
```

> map -- 转换每个元素，返回转换后的数组。

```js
const counts = [1, 2, 3, 4, 5]
const counts2 = counts.map(ele => ele * 2)
console.log({ counts2 }) // [2,4,6,8,10]
```

> every -- 是否每个元素符合某个条件，有不符合的，返回 false，都符合，返回 true。

```js
const counts = [1, 2, 3, 4, 5]
const isAllThan4 = counts.every(ele => ele > 4)
console.log({ isAllThan4 }) // { isAllThan4: false }
```

> some -- 是否某些元素符合某个条件，有符合的，返回 true，遍历完了，都不符合，返回 false。

```js
const counts = [1, 2, 3, 4, 5]
const hasThan4 = counts.some(ele => ele > 4)
console.log({ hasThan4 }) // { hasThan4: true }
```

### 排序和反转

> reverse -- 返回数组，会改变原数组，返回同一个数组的引用。toReversed 不改变原数组反转。

```js
const counts = [1, 2, 3, 4, 5]
const result = counts.reverse()
console.log({ result, counts }) // counts 被改变
```

> sort -- 接收一个可选的排序函数，会改变原数组，返回同一个数组的引用。 toSorted 不改变原数组排序。

```js
const counts = [1, 5, 2, 3, 4]
const result = counts.sort() // 默认升序
console.log({ result, counts })
```

按照降序排列：

```js
const counts = [1, 5, 2, 3, 4]
const result = counts.sort((cur, next) => {
  // 末减初 -- 降序
  return next - cur
})
console.log({ result, counts })
```

### 迭代方法

`Symbol.iterator`，数组原型上实现了可迭代协议，可使用展开语法`...`和`for of`迭代。

```js
const counts = [1, 5, 2, 3, 4]
for (const item of counts) {
  console.log({ item })
}

const iterator = counts[Symbol.iterator]()
let done = false
while (!done) {
  const { done: d, value } = iterator.next()
  done = d
  console.log({ value })
}
```

`values` 返回一个由元素组成的迭代对象，`keys`也是类似的功能，返回索引组成的迭代对象。

```js
const array1 = ['a', 'b', 'c']
const iterator = array1.values()

for (const value of iterator) {
  console.log(value)
}
```

## 小结

- 数组是多个变量的有序储存结构；
- 数组元素和大小都是动态的；
- 有多个遍历方法，需要按照实际需要选择符合的方法。
