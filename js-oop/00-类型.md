# 类型

业界实现面向对象的方式有很多，比如 C++、Java、Python 等。这些语言都是基于类的面向对象语言，而 JavaScript 是**基于原型**的面向对象语言。传统的面向对象的概念不一定适用于 JavaScript，但是 JavaScript 也有自己的面向对象的特性。

## 面向对象的特性

- 封装：将数据和行为组合在一个包中，并对对象的使用者隐藏数据的实现细节。
- 聚合：一个对象可以包含其他对象。
- 继承：一个对象可以继承另一个对象的属性和方法。
- 多态：一个接口可被多个对象实现。多态是继承的具体实现。

## 引用类型和原始类型

JavaScript 中的数据类型分为两种：原始类型和引用类型。JavaScript 编程就好像从一块空白石板开始：可在上面组织任何你想要的东西。

几乎所有 JavaScript 的数据要么是对象，要么从对象中获取，就连函数也是特殊的对象，函数的这个特殊性，使得它成为 JavaScript 中的一等公民 -- **可以像操作对象一样操作函数，可作为参数，可作为返回值，可作为对象属性，可作为数组元素，即可作为值传来传去。**

理解对象是理解 JavaScript 的关键，对象可随时创建，随时添加属性、删除属性，对象如此灵活，使得 JavaScript 具备其他语言所不具备的特性。

JavaScript 中的原始类型有： `undefined`、`null`、`boolean`、`number`、`string`、`symbol`、`bigInt`。原始类型的值是不可变的，原始类型的值是直接访问的，原始类型的值是按值访问的。

JavaScript 中的引用类型有： `object` 、 `array` 、 `function` 。引用类型的值是可变的，引用类型的值是通过引用访问的，引用类型的值是按引用访问的。**引用类型保存为对象，本质是指向内存位置的引用。**

其他编程语言使用栈存储原始类型，有堆存储引用类型，JavaScript 则不同，使用一个**变量对象**跟踪变量的生存期。原始值被直接保存在变量对象内，而引用值作为一个指针保存在变量对象内，指针指向内存地址。

## 原始类型

`boolean`、`number` 、`string` 的行为类似。

`null`、`undefined`、`symbol` 的行为有点特殊。

- `null`：表示一个空对象指针，`typeof null` 返回 `'object'`。
- `undefined`：表示一个未初始化的变量，`typeof undefined` 返回 `'undefined'`。
- `symbol`：表示唯一的值，`typeof Symbol()` 返回 `'symbol'`。

原始值赋值给变量，值被复制到变量中，变量之间互不影响。

> 类型检测：`typeof` 运算符返回一个字符串，表示未经计算的操作数的类型。

typeof 运算符返回的类型有：`'undefined'`、`'boolean'`、`'number'`、`'string'`、`'symbol'`、`'object'`、`'function'`。

`null` 的类型是 `'object'` ，这是 JavaScript 的一个历史遗留问题，实际上 `null` 是一个表示空对象指针的特殊值。

检查一个值是否为 `null` ，可以使用 `===` 运算符。

```js
const isNull = value => value === null;
```

检查一个值是否为 `undefined` ，可以使用 `===` 运算符。

```js
const isUndefined = value => value === undefined;
```

检测一个值是否为 `null` 或 `undefined` ，可以使用 `==` 运算符。

```js
const isNullish = value => value == null;
```

### 为何原始类型有方法？

读取原始类型时，js 引擎会自动原始类被创建，随后该对象类型被销毁，故能调用方法。

```js
const name = 'string'
console.log(name.charAt(0))
```

以上过程 js 引擎做了类似的工作：

```js
const name = 'string'
let temp = new String(name) // 创建一个 string 包装类型
const first = temp.charAt(0)
temp = null
console.log(first)
```

临时对象是读取时才创建，故使用 instanceof 无法判断原始类型的。

### symbol 有哪些使用场景？

symbol 是唯一个没有字面量的原始类型，只能使用`Symbol`创建 symbol 类型。

> symbol 类型的特点：每个值都是唯一的。

```js
const key = Symbol('unique')
const key2 = Symbol('unique')
console.log(typeof key) // symbol
console.log(key == key2) // false
console.log(key === key2) // false
console.log(key.description) // unique
console.log(key2.toString() === key.toString()) // true
```

> 隐藏属性：symbol 作为键，通过字符串或者`for in`无法访问

```js
const age = Symbol('age')
const obj = {
  name: 'jack',
  [age]: 30,
}
console.log({ ...obj })
console.log(obj.age) // undefined
console.log(obj[age])

for (const property in obj) {
  console.log(`${property}: ${obj[property]}`) // name:jack
}
```

> symbol 的最佳使用场景：

- 隐藏属性：symbol 类型属性，外部无法访问，只能通过`Object.getOwnPropertySymbols(obj)`或者`Reflect.ownKeys(obj)`访问；
- 保证值唯一且不可变：结合 const 能保证值唯一，且不可变；

### `undefined`和`null`特殊性

undefined 是一种类型，也是一个值，表示变量未初始化。

null 是一个值，也是类型，但是`typeof`，检测不到。

## 引用类型

对象是属性的无序列表。属性包含键和值。键是一个**字符串**，属性的值可以是任何类型的值。值为函数，称为方法。

### 创建对象

有很多种方式可以创建对象，比如使用对象字面量、使用构造函数、使用 `Object.create()` 方法。

| 方式       | 语法     | 示例                        | 说明                   |
| ---------- | -------- | --------------------------- | ---------------------- |
| 对象字面量 | `{}`     | `const a = {}`              | 最常用的创建对象的方式 |
| 构造函数   | `new`    | `const a = new Object()`    | 使用构造函数创建对象   |
| 使用函数   | `create` | `const a = Object.create()` | 创建一个没有原型的对象 |

JavaScript 有垃圾回收机制，使用对象时无需担心内存分配，但是最好在不再使用对象时将其引用解除：**设置为 null**。

> 字面量的方式虽然没有调用 `new Object` ，但是引擎帮忙调用了。

```js
let obj = {}
// do something
obj = null // dereference 解除引用
```

### 内建类型

有一些内置的引用类型，有特殊病用处：

| 类型     | 描述         | 字面量                    | new                                    |
| -------- | ------------ | ------------------------- | -------------------------------------- |
| Array    | 数组         | `const arr = [1,2]`       | `const arr = new Array(1,2)`           |
| Date     | 日期         | 没有                      | `let date = new Date()`                |
| Error    | 错误         | 没有                      | `let err = new Error('new error')`     |
| RegExp   | 正则         | `let numReg = /\d+/g`     | `let numReg = new RegExp("\\d+","g")`  |
| Function | 函数         | `function a(v){return v}` | `let a = new Function('v','return v')` |
| Object   | 通用对象类型 |                           |                                        |

> new Function 创建函数，可读性差，难以调式，最常用字面量形式。

利用这个特点可防止页面被他人调试：

```js
setInterval(() => {
    ;
    (function() {
        try {
            new Function('debugger')() // js 调试器认不出这个函数
            arguments.callee()
        } catch (error) {}
    })()
}, 500)
```

### 访问属性

通过 `.` 或者 `[]` 访问属性：

```js
let arr = []
arr.push(1) // 点访问
arr['push'](2) // [] 访问
const method = 'push'
arr[method](3) // 动态属性
```

### 判断引用类型

函数和数组最容易判断的引用类型，使用 typeof 判断函数，使用 `Array.isArray` ，判断数组。其他引用类型判断比较棘手，使用 typeof，都返回 `object` 。

使用 `instanceof` 判断其他类型。

```js
const date = new Date()
const reg = new RegExp('\\d+', 'g')
const err = new Error()
console.log(date instanceof Date)
console.log(reg instanceof RegExp)
console.log(err instanceof Error)
```

> instanceof 的缺陷？

iframe 之间传递 date reg 和 err，检测不出来。

```html
<!-- child.html -->
<button id="send">发送</button>
<script>
  send.onclick = function() {
    const arr = [1, 2]
    const date = new Date()
    const obj = {}
    const reg = new RegExp('\\d+', 'g')
    const err = new Error('test')
    arr.push(Math.random() * 10)
    console.log(arr instanceof Array)
    console.log(date instanceof Date)
    console.log(reg instanceof RegExp)
    const event = new CustomEvent('myCustomEvent', {
      detail: {
        arr,
        date,
        reg,
        err,
      }
    })
    window.parent.document.dispatchEvent(event)
  }
</script>
```

在 parent.html 中接收值：

```html
<iframe src="/child.html" frameborder="0" width="480" height="320"></iframe>
<script>
  window.document.addEventListener('myCustomEvent',e=>{
    const {arr,reg,date,err} = e.detail
    console.log(arr instanceof Array) // false
    console.log(date instanceof Date) // false
    console.log(reg instanceof RegExp) // false
    console.log(err instanceof Error) // false
  })
</script>
```

instanceof 判断失败了。

## 小结

- js 中有原始类型和引用类型两大类型；
- 原始类型：undefined、null、number、string、boolean、bigint 和 symbol，不能存储属性和方法，读取时自动包装，null 和 undefined 没有任何方法和属性。
- 引用类型：对象，能存储属性和方法。对象、数组、函数、Date、RexGxp、Error。
- 使用`typeof`判断原始类型和函数；
- 使用`Array.isArray`判断数组；
- 使用`instanceof`判断 Date、Error 和 RegExp；
- instanceof 判断 iframe 传递的值，会失效；
- 判断 null 用 `value === null`，判断 null 或者 undefined，使用`value == null`;
- 原始类型读取时会自动创建包装类型，故可调用方法。
