# 渲染函数

使用单文件组件时，可以使用模板语法 `template` 来编写组件的模板，但是在某些情况下，可能需要使用渲染函数来编写组件的模板。
vue 会通过 [compile-sfc](https://www.npmjs.com/package/@vue/compiler-sfc) 把模板编译成渲染函数，渲染函数是一个函数，接收三个参数，返回一个 `VNode` 对象。

```js
import {
  h
} from 'vue'
export default {
  render() {
    return h('div', 'Hello World')
  }
}
```

日常项目中使用 template 模板语法就足够了，在写通用的组件时，需要使用到渲染函数，它灵活的特点给了开发人更多的控制权。

## 渲染函数的基本用法

在这个例子中， `render` 函数返回一个 `VNode` 对象， `h` 接收三个参数，第一个参数是标签名或者组件，第二个参数是 props，第三个参数是子节点。
`VNode` 对象是一个虚拟节点，用来描述真实 DOM 节点的结构，包括标签名、props、子节点等信息。
`VNode` 对象的结构如下：

```js
{
  type: 'div',
  props: {
    id: 'app',
    class: 'container'
    onClick: () => {}
    // ... 其他属性
  },
  children: undefined
  // ... 其他属性 以上三个属性是最重要的
}
```

> 当渲染 DOM 时，type 是标签名，渲染组件时，type 是组件的配置对象。

 通过 h 函数，可操作 VNode，比如过滤掉某些节点，或者添加一些属性，从而让组件更通用和易用。

## 使用 render 函数封装 tab-container 组件

先看使用方式：

```html
<script setup>
  import {
    ref
  } from 'vue'
  import {
    Tab,
    TabContainer,
    TabContent
  } from './TabContainer.js'
  const activeTabId = ref('1')
  const inputText = ref('')
  const myInput = ref('')
</script>
<template>
  <div class="TabsDemo">
    <TabContainer v-model="activeTabId">
      <Tab title="Tab 1" id="1">tab 1000</Tab>
      <Tab title="Tab 2" id="2">tab 2 </Tab>
      <Tab title="Tab 3" id="3">tab 3 </Tab>
      <TabContent id="1">
        <h3>Tab 1</h3>
        <input type="text" v-model="inputText" />
        <p>Content 1</p>
      </TabContent>
      <TabContent id="2">
        <h3>Tab 2</h3>
        <p>Content 2</p>
      </TabContent>
      <TabContent id="3">
        <div>
          <input type="text" v-model="myInput" />
          <p>myInput : {{ myInput }}</p>
          <h3>Tab 3</h3>
        </div>
      </TabContent>
    </TabContainer>
  </div>
</template>
```

`TabContainer` 、 `Tab` 、 `TabContent` 是三个组件， `TabContainer` 是一个容器组件， `Tab` 是一个标签组件， `TabContent` 是一个内容组件，这三个组件是一个组合组件，用来实现 tab 切换功能。
`Tab` 和 `TabContent` 都接收一个 `id` 属性， `TabContainer` 通过 `v-model` 接收一个当前激活的 Tab 的 id 属性，显示响应的 TabContent。
`Tab` 和 `TabContent` 都有默认插槽，用来显示标签和内容。
先看 `Tab` 和 `TabContent` 的实现：

```js
function withTabId(name) {
  return defineComponent({
    name,
    props: {
      id: {
        type: String || Number,
        required: true
      }
    },
    setup(props, {
      slots
    }) {
      onMounted(() => {
        console.log(`${name}  ${props.id} mounted`)
      })
      onUnmounted(() => {
        console.log(`${name} ${props.id} unmounted`)
      })
      return () => h('div', slots.default?.())
    }
  })
}
export const Tab = withTabId('Tab')
export const TabContent = withTabId('TabContent')
```

它们的实现是一样的，都是通过 `withTabId` 函数来创建一个组件，接收组件名，返回一个组件。
关键是 `TabContainer` 的实现：

```js
const TabContainer = defineComponent({
  name: 'TabContainer',
  props: {
    modelValue: {
      type: String || Number,
      required: true
    },
  },
  emits: ['update:modelValue'],
  setup(props, {
    slots,
    emit
  }) {
    // 获取子组件
    const children = slots.default?.() ?? []
    /**
     * 过滤 Tab 组件
     * @param component 组件
     * @returns 返回是否是 Tab 组件
     */
    function tabFilter(component) {
      return component.type === Tab
    }
    const tabs = computed(() => {
      const tabVNodes = children.filter(tabFilter).map((Tab) => {
        return h(Tab, {
          ...Tab.props,
          key: Tab.props.id,
          class: {
            active: Tab.props.id === props.modelValue,
              tab: true
          },
          onClick: () => {
            // console.log('Tab.props.id:', Tab.props.id)
            emit('update:modelValue', Tab.props.id)
          }
        })
      })
      return tabVNodes
    })

    function contentFilter(component) {
      return component.type === TabContent && component.props.id === props.modelValue
    }
    const activeContent = computed(() => {
      const activeContent = children.find(contentFilter)
      const activeContentVNode = h(activeContent, {
        ...activeContent.props,
        key: activeContent.props.id
      })
      return activeContentVNode
    })
    return () => {
      let CurContent = activeContent.value
      return h('div', {
        class: 'tab-container'
      }, [
        h('div', {
          class: 'tabs'
        }, tabs.value),
        h('div', {
          class: 'tab-content'
        }, CurContent)
      ])
    }
  }
})
```

三个关键点：
1. 通过 `slots.default?.()` 获取子组件；
2. 通过 VNode 的 type 属性拾取出 Tab 组件，然后通过 props 传递 `class` 和 `onClick` 事件；
3. 使用 computed 计算属性，当点击tab时， 重新渲染当前激活的 TabContent。
实现 TabContainer 的关键，就是通过h函数，操作VNode，过滤掉不需要的节点，添加一些属性，从而实现Tab切换功能。
这种模式在封装成对使用的组件时，非常有用，相当强大，比如封装 `Select` 和 `Option` 组件，封装 `Table` 和 `TableColumn` 组件等。
当标签嵌套深了，h 函数的嵌套也会很深，可读性降低，这时候可以使用 jsx 语法，更加直观和简洁。

## 使用 jsx 语法代替 h 函数

```jsx
defineComponent({
    props: {
      keepAlive: {
        type: Boolean,
        default: false
      }
  },
  // ... 不变
    return () => {
      let CurContent = activeContent.value
      if (props.keepAlive) {
        CurContent = h(KeepAlive, activeContent.value)
      }
      return (
        <div class="tab-container">
          <div class="tabs">{tabs.value}</div>
          <div class="tab-content">{CurContent}</div>
        </div>
      )
    }
})
```

使用 jsx 语法，更加直观和简洁，但是需要配置 jsx 插件，这里不做详细介绍。
同时我们给 `TabContainer` 添加了一个 `keepAlive` 属性，用来控制是否缓存 TabContent 组件。

## render-prop 模式

`render-prop` 模式是一种组件设计模式，通过 props 接收一个 render 函数，把组件的渲染逻辑交给使用者，从而实现更加灵活的组件。
看一个组件原型：
[form-table组件](https://cdn.jsdelivr.net/npm/zqj-pics/vue3/form-table.png)
组件的布局有点像表格，可以跨列，但是渲染的数据是一个对象， key 往往是文字，而 value 的显示需要实现自定义，可能显示一个按钮，一张图片，变化非常多。
实现这个组件的关键是，支持自定义渲染 value，这时候就可以使用 `render-prop` 模式。
先看一个不易用不优雅的实现：

> 使用方式

```html
<FormTable :data="lessonPackageArr" :fleldsInfo="lessonPackageInfo" :maxColumn="3" label-width="120px">
  <template #presentedHours="{ data }">
    <div class="flex-box between">
      <span>{{ data.presentedHours }}</span>
      <span class="column-btn" @click="editPresentedHours(data)">修改</span>
    </div>
  </template>
  <template #gifts="{ data }">
    <div class="flex-box between">
      <span>{{ data.gifts }}</span>
      <span class="column-btn" @click="editPresentedHours(data)">修改</span>
    </div>
  </template>
</FormTable>
```

重点关注 fleldsInfo 属性，他绑定了一个对象，用来配置自定义显示的逻辑：

```js
// 一个对象，用于配置标题列和标题列对应的字段
// type 指定值的类型，现在组件内部设置可能显示哪些类型的值了
// 对于服务其返回 1 0 需要显示 是否的数，提供一个 map_data 来映射
// column 属性设置跨列
// 需要自定义显示内容 提供 slot
lessonPackageInfo: {
  gifts: {
    type: 'text',
    desc: '赠送礼物',
    column: 3,
    slot: true
  },
}
```

使用时候，需要关注三个属性：

1. type：指定值的类型，现在组件内部设置可能显示哪些类型的值了
2. desc：标题列，显示在左侧，用来描述这一列的内容
3. slot：是否自定义显示内容，如果为 true，需要提供一个 slot

光这一个配置，就组件非常难用了，使用者需要关注很多细节，这时候就可以使用 `render-prop` 改善。

> 组件里的实现方式，就不展示了，内部使用 `type` 和 `slot` 结合 `v-if` 和动态插槽实现的，非常不优雅。

先看使用方式：

```html
<script setup lang="jsx">
  const dataInfo = {
    gifts: 'https://cdn.jsdelivr.net/npm/zqj-pics/vue3/gifts.png',
    name: '张三'
  }

  const cols = [{
      label: '姓名',
      prop: 'name'
    },
    {
      label: '赠送礼物',
      prop: 'gifts',
      span: 3,
      render: (data) => {
        const imgSrc = data.gifts
        return h('span', null, h('img', {
          src: imgSrc,
          style: {
            width: '50px'
          }
        }))
      }
    }
  ]
</script>

<template>
  <FormTable :data="dataInfo" :cols="cols" />
</template>
```

使用方式解读：

1. data 用来接收一个对象，这是需要渲染的数据；

2. cols 用来接收一个数组，这是配置渲染的列，每一列都有一个 render 函数，用来自定义渲染 value。

后面的使用方式简单明了，符合直觉，使用者对 value 的显示形式具有完全的控制权，这就是 `render-prop` 模式的优势。

<!-- TODO FormTable 的实现 -->

## 小结

* 渲染函数是一个函数，接收三个参数，返回一个 `VNode` 对象；
* `VNode` 对象是一个虚拟节点，用来描述真实 DOM 节点的结构，包括标签名、props、子节点等信息；
* 通过 VNode 的 type 属性可拾取出现想要的子组件，然后操作它，比如传递属性、绑定事件；
* `render-prop` 模式是一种组件设计模式，通过 props 接收一个 render 函数，把组件的渲染逻辑交给使用者，从而实现更加灵活的组件。
