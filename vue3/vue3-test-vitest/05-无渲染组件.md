# 无渲染组件

vue 中复用**状态逻辑**的方式有多种，比如 mixin、provide/inject、vuex 等。但是这些方式都有各自的缺点，比如 mixin 会导致命名冲突，vuex 会导致代码冗余等。vue3 提供了组合式 api，可以更好的解决这些问题。

> 状态逻辑：携带了组件状态的函数或者组件状态和操作这些状态的封装，函数操作了状态，会响应到组件上。

使用 `无渲染组件` 也可以实现**状态逻辑**的复用，无渲染组件不提供模板和样式，只提供状态的组件，模板和样式由使用者从外部传入，组件使用者对组件模板和样式具有很大的控制权，保证了组件的灵活性。

## 无渲染组件结合插槽实现复用状态逻辑

无渲染组件结合插槽，可以轻松实现状态逻辑的复用。

之前有一个 `useJoke` 的 hook，用于获取笑话数据，现在将其封装成一个无渲染组件 `FetchJoke.vue` ，可很好地看到两者的区别。

```html
<!--
 * @Author      : ZhouQiJun
 * @Date        : 2024-08-29 09:19:45
 * @LastEditors : ZhouQiJun
 * @LastEditTime: 2024-08-29 09:29:34
 * @Description : FetchJoke.vue 无渲染组件实现状态逻辑复用
-->
<script>
  import {
    ref
  } from 'vue'

  export default {
    name: 'FetchJoke',
    setup(props, {
      slots
    }) {
      const loading = ref(false)
      const joke = ref('')
      const fetchJoke = async () => {
        loading.value = true
        const headers = {
          accept: 'application/json'
        }
        const res = await fetch('https://icanhazdadjoke.com', {
          headers
        })
        const data = await res.json()
        joke.value = data.joke
        loading.value = false
      }
      fetchJoke()
      return () => {
        return slots.default({
          loading: loading.value,
          joke: joke.value,
          fetchJoke
        })
      }
    }
  }
</script>
```

通过默认插槽 `slots.default` 将状态逻辑暴露给使用者，使用者可以自由控制组件的模板和样式。

```html
<script setup>
  import FetchJoke from './FetchJoke.vue'
</script>

<template>
  <FetchJoke v-slot="{ loading, joke, fetchJoke }">
    <div class="JokeContainer">
      <h3>笑话大全</h3>
      <p>{{ loading ? 'loading' : joke }}</p>
      <button @click="fetchJoke">获取笑话</button>
    </div>
  </FetchJoke>
</template>

<style scoped lang="scss">
  .JokeContainer {
    // scss code
  }
</style>
```

通过这个例子，可以看到无渲染组件的优势，可以更好地实现状态逻辑的复用，同时保证了组件的灵活性。

## 无渲染组件结合 provide/inject 实现 react 的 context 功能

## 无渲染组件结合 children 实现对子组件的控制
