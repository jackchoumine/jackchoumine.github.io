import{_ as s,o as e,c as a,a as n}from"./app.ec99a0c4.js";const u=JSON.parse('{"title":"vue2 常见面试题","description":"","frontmatter":{},"headers":[{"level":2,"title":"什么是MVVM？","slug":"什么是mvvm","link":"#什么是mvvm","children":[]},{"level":2,"title":"Vue的生命周期","slug":"vue的生命周期","link":"#vue的生命周期","children":[]},{"level":2,"title":"父子组件生命周期钩子执行顺序","slug":"父子组件生命周期钩子执行顺序","link":"#父子组件生命周期钩子执行顺序","children":[]},{"level":2,"title":"Vue的响应式原理","slug":"vue的响应式原理","link":"#vue的响应式原理","children":[]},{"level":2,"title":"v-for 和 v-if 优先级","slug":"v-for-和-v-if-优先级","link":"#v-for-和-v-if-优先级","children":[]},{"level":2,"title":"v-for 中key的作用","slug":"v-for-中key的作用","link":"#v-for-中key的作用","children":[]},{"level":2,"title":"Vue的路由实现原理","slug":"vue的路由实现原理","link":"#vue的路由实现原理","children":[]},{"level":2,"title":"vuex 的原理","slug":"vuex-的原理","link":"#vuex-的原理","children":[]}],"relativePath":"vue2/常见面试题.md"}'),l={name:"vue2/常见面试题.md"},o=n(`<h1 id="vue2-常见面试题" tabindex="-1">vue2 常见面试题 <a class="header-anchor" href="#vue2-常见面试题" aria-hidden="true">#</a></h1><h2 id="什么是mvvm" tabindex="-1">什么是MVVM？ <a class="header-anchor" href="#什么是mvvm" aria-hidden="true">#</a></h2><p>MVVM 是Model-View-ViewModel 的缩写。MVVM 是一种设计思想。Model 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来；ViewModel 是一个同步View 和 Model的对象。</p><h2 id="vue的生命周期" tabindex="-1">Vue的生命周期 <a class="header-anchor" href="#vue的生命周期" aria-hidden="true">#</a></h2><p>Vue 实例从创建到销毁的过程，就是生命周期。vue 提供的生命周期函数有：beforeCreate、created、beforeMount、<strong>mounted</strong>、beforeUpdate、updated、<strong>beforeDestroy</strong>、destroyed。</p><p>这些生命周期函数提供了在特定阶段添加自定义逻辑的机会。</p><h2 id="父子组件生命周期钩子执行顺序" tabindex="-1">父子组件生命周期钩子执行顺序 <a class="header-anchor" href="#父子组件生命周期钩子执行顺序" aria-hidden="true">#</a></h2><p>父组件和子组件的生命周期钩子执行顺序是<strong>创建是先父后子</strong>，<strong>渲染、更新和销毁时先子后父</strong>。</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;"># 创建是先父后子</span></span>
<span class="line"><span style="color:#FFCB6B;">父</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">beforeCreate</span><span style="color:#A6ACCD;"> -</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">父</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">created</span><span style="color:#A6ACCD;"> -</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">父</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">beforeMount</span><span style="color:#A6ACCD;"> -</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">子</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">beforeCreate</span><span style="color:#A6ACCD;"> -</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">子</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">created</span><span style="color:#A6ACCD;"> -</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">子</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">beforeMount</span><span style="color:#A6ACCD;"> -</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">子</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">mounted</span><span style="color:#A6ACCD;"> -</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">父</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">mounted</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># 更新和销毁时先子后父</span></span>
<span class="line"><span style="color:#FFCB6B;">父</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">beforeUpdate</span><span style="color:#A6ACCD;"> -</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">子</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">beforeUpdate</span><span style="color:#A6ACCD;"> -</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">子</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">updated</span><span style="color:#A6ACCD;"> -</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">父</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">updated</span></span>
<span class="line"><span style="color:#FFCB6B;">父</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">beforeDestroy</span><span style="color:#A6ACCD;"> -</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">子</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">beforeDestroy</span><span style="color:#A6ACCD;"> -</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">子</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">destroyed</span><span style="color:#A6ACCD;"> -</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">父</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">destroyed</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="vue的响应式原理" tabindex="-1">Vue的响应式原理 <a class="header-anchor" href="#vue的响应式原理" aria-hidden="true">#</a></h2><p>Vue 2 中的响应式原理主要基于 <strong>Object.defineProperty()</strong> 函数。当你创建一个 Vue 实例时，Vue 会遍历 data 对象的所有属性，并使用 Object.defineProperty() 将它们转换为 getter 和 setter，代理属性，从而实现对数据的监听和响应。</p><p>具体来说，当访问数据属性时，Vue 会记录当前的依赖关系。如果这个属性被用于渲染视图，那么这个渲染函数就会成为这个属性的依赖。当数据发生变化时，它会通知所有依赖于该数据的地方，从而触发相应的更新。</p><h2 id="v-for-和-v-if-优先级" tabindex="-1">v-for 和 v-if 优先级 <a class="header-anchor" href="#v-for-和-v-if-优先级" aria-hidden="true">#</a></h2><p>当 v-for 和 v-if 同时存在于同一个节点时，v-for 的优先级高于 v-if。</p><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">v-for</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">item in list</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">v-if</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">item.show</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">{{ item.name }}</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="v-for-中key的作用" tabindex="-1">v-for 中key的作用 <a class="header-anchor" href="#v-for-中key的作用" aria-hidden="true">#</a></h2><p>在 Vue 中使用 v-for 进行列表渲染时，每个节点都会有一个<strong>唯一且稳定</strong>的 key 值。key 的作用主要是为了<strong>高效的更新虚拟 DOM</strong>。</p><p>当数据发生变化时，Vue 会根据新数据生成一个新的虚拟 DOM 树，然后通过 diff 算法对比新旧虚拟 DOM 树的差异，最终只更新差异部分的真实 DOM。</p><p>如果没有 key，Vue 会使用一种<strong>最大限度减少移动操作</strong>的算法，但是这种算法有时候会出现错误，导致页面渲染错误。</p><h2 id="vue的路由实现原理" tabindex="-1">Vue的路由实现原理 <a class="header-anchor" href="#vue的路由实现原理" aria-hidden="true">#</a></h2><p>Vue 的路由实现原理主要是通过<strong>监听 URL 的变化</strong>，然后匹配路由规则，<strong>显示相应的组件</strong>。</p><h2 id="vuex-的原理" tabindex="-1">vuex 的原理 <a class="header-anchor" href="#vuex-的原理" aria-hidden="true">#</a></h2><p>全局混入，混入钩子会先于组件自身的钩子执行，这样就可以在组件内部访问到 store 对象。</p>`,23),p=[o];function t(r,c,i,D,y,C){return e(),a("div",null,p)}const A=s(l,[["render",t]]);export{u as __pageData,A as default};
