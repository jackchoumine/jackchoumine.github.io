import{_ as e,o as t,c as a,a as o}from"./app.6b3289bc.js";const u=JSON.parse('{"title":"两种阻止事件冒泡","description":"","frontmatter":{},"headers":[{"level":2,"title":"最佳实践","slug":"最佳实践","link":"#最佳实践","children":[]}],"relativePath":"web/js/两种阻止事件冒泡.md"}'),r={name:"web/js/两种阻止事件冒泡.md"},s=o('<h1 id="两种阻止事件冒泡" tabindex="-1">两种阻止事件冒泡 <a class="header-anchor" href="#两种阻止事件冒泡" aria-hidden="true">#</a></h1><p><code>stopImmediatePropagation</code> 、 <code>stopPropagation</code> 都能阻止事件向祖先元素传递，有什么区别呢？</p><p>一定有区别，否则不会存在两个方法。</p><p>stopImmediatePropagation 能阻止目标元素的<strong>其他相同事件的监听器被调用</strong>，而 stopPropagation 只是阻止事件向祖先元素传递。</p><blockquote><p>一个事件，就可以有多个监听器，这些监听器是按照添加的顺序执行的。</p></blockquote><h2 id="最佳实践" tabindex="-1">最佳实践 <a class="header-anchor" href="#最佳实践" aria-hidden="true">#</a></h2><p><code>stopPropagation</code> 就能应对大部分情况了。</p>',7),_=[s];function n(c,d,p,i,h,l){return t(),a("div",null,_)}const f=e(r,[["render",n]]);export{u as __pageData,f as default};
