import{_ as e,o as t,c as a,a as i}from"./app.c96a0340.js";const _=JSON.parse('{"title":"vue2 组件测试总结","description":"","frontmatter":{},"headers":[{"level":2,"title":"测试异步代码","slug":"测试异步代码","link":"#测试异步代码","children":[{"level":3,"title":"vue 异步更新 DOM","slug":"vue-异步更新-dom","link":"#vue-异步更新-dom","children":[]},{"level":3,"title":"外部函数的异步调用","slug":"外部函数的异步调用","link":"#外部函数的异步调用","children":[]}]}],"relativePath":"vue2/test-vue-summary.md"}'),o={name:"vue2/test-vue-summary.md"},d=i('<h1 id="vue2-组件测试总结" tabindex="-1">vue2 组件测试总结 <a class="header-anchor" href="#vue2-组件测试总结" aria-hidden="true">#</a></h1><h2 id="测试异步代码" tabindex="-1">测试异步代码 <a class="header-anchor" href="#测试异步代码" aria-hidden="true">#</a></h2><p>jest 测试代码是同步的，在断言之前需要等待异步代码之前完，vue 组件中的异步代码有两种：</p><ul><li>vue 异步更新 DOM；</li><li>外部函数的异步调用，比如 setTimeout、fetch 等。</li></ul><h3 id="vue-异步更新-dom" tabindex="-1">vue 异步更新 DOM <a class="header-anchor" href="#vue-异步更新-dom" aria-hidden="true">#</a></h3><p>当一个响应式数据变化后，要断言这个变化，需要等待 DOM 更新后才能断言。可使用 <code>vm.$nextTick</code> 、 <code>Vue.nextTick</code> ，更加简洁明了的方式是 <code>await</code> 那个更新状态的方法，比如 <code>await input.setValue(&#39;update input&#39;)</code> 。</p><p>可以被 <code>await</code> 的方法有：</p><ul><li>setProps</li><li>setDate</li><li>trigger</li><li>setValue</li><li>setChecked</li><li>setSelected</li></ul><h3 id="外部函数的异步调用" tabindex="-1">外部函数的异步调用 <a class="header-anchor" href="#外部函数的异步调用" aria-hidden="true">#</a></h3><p>常见是的 http 调用，比如 fetch、axios、vuex的action等。这种情况下，需要使用 <code>mock</code> 模拟外部调用，而不是真的让异步调用执行，比如 <code>jest.mock(&#39;axios&#39;)</code> 。</p><p>使用 <code>flush-promises</code> 包，flush-promises 会刷新所有处于 pending 状态或 resolved 状态的 Promise。</p><blockquote><p>为何不使用 <code>await</code> 或者 <code>await Vue.$nextTick()</code> ？</p></blockquote><p>Vue 更新其组件和完成其 Promise 对象的时机不同。</p><p>一个易于遵循的规则是在诸如 trigger 或 setProps 的变更时始终使用 await。如果你的代码依赖一些诸如 axios 的异步操作，也要为 flushPromises 加入一个 await。</p>',14),s=[d];function c(l,r,u,n,h,p){return t(),a("div",null,s)}const v=e(o,[["render",c]]);export{_ as __pageData,v as default};
